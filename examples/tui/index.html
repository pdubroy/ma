<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv='Content-type' content='text/html; charset=utf-8'>
    <title>Basic Example with JSX and ES6 features</title>
    <style>
      body {
        font-family: Menlo, Monaco, sans-serif;
      }
      html, body {
        height: 100%;
        margin: 0;
      }
      #container {
        display: flex;
        height: 100%;
        flex-direction: column;
      }
      #container > div {
        display: flex;
        flex: 1;
        flex-direction: column;
        padding: 16px;
      }
      .vat {
        flex: 1;
      }
      .item {
        background-color: white;
        border: 1px solid transparent;
        border-radius: 6px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
        display: inline-block;
        font-size: 24px;
        margin: 4px;
        padding: 8px 24px;
        position: absolute;
      }
      .item.dragging {
        color: white;
        box-shadow: none;
        opacity: 0.2;
      }
      input {
        border: 1px solid #ccc;
        font-size: 24px;
        margin-bottom: 16px;
        padding: 0.3em;
        width: 40%;
      }
    </style>
  </head>
  <body>
    <div id="container">
      <p>If you can see this, React is not working right.</p>
    </div>
    <script src="third_party/react-0.13.3/react.js"></script>
    <script src="third_party/react-0.13.3/JSXTransformer.js"></script>
    <script src="third_party/ReactDnD.min.js"></script>
    <script src="third_party/immutable.min.js"></script>
    <script src="../../dist/ma-bundle.js"></script>
    <script type="text/jsx;harmony=true">
      var _ = ma.match.ANY;
      var all = ma.Vat.all;
      var and = ma.Vat.and;
      var DragDropContext = ReactDnD.DragDropContext;
      var DragSource = ReactDnD.DragSource;
      var DropTarget = ReactDnD.DropTarget;

      function assert(cond, message) {
        if (!cond) {
          console.error(message || 'assertion failed');
        }
      }

      function toJS(val) {
        return typeof val.toJS === 'function' ? val.toJS() : val;
      }

      function isNumber(x) {
        if (Object.prototype.toString.call(x) === '[object Number]') {
          return true;
        }
        var val = toJS(x);
        if (Array.isArray(val) && val.length === 3 && val[1] === "+") {
          return true;
        }
      }

      function rand(s, m) {
        return (Math.random() + Math.random() + Math.random() + Math.random() + Math.random() + Math.random()) * s + m;
      }

      // VatItem
      // -------

      // ReactDnD Helpers

      var cardSource = {
        beginDrag: function (props, monitor) {
          return props.value;
        }
      };

      function collectSource(connect, monitor) {
        return {
          connectDragSource: connect.dragSource(),
          isDragging: monitor.isDragging()
        }
      }

      // VatItem Component

      class VatItem extends React.Component {
        render() {
          var connectDragSource = this.props.connectDragSource;
          var className = 'item';
          if (this.props.isDragging) {
            className += ' dragging';
          }
          var value = this.props.value;
          return connectDragSource(
            <div style={{top: value.get('offsetTop'), left: value.get('offsetLeft')}}
                 className={className}
                 onClick={this.handleClick.bind(this)}>
              {this.getLabel()}
            </div>
          );
        }
        getLabel() {
          return this.props.value.get('name');
        }
        handleClick() {
          console.log(this.props.value.toJS());
        }
      }

      var Card = DragSource('card', cardSource, collectSource)(VatItem);

      // VatView
      // -------

      var viewTarget = {
        canDrop: function (props) {
          return true;
        },
        drop: function (props, monitor) {
          var delta = monitor.getDifferenceFromInitialOffset();
          vat.update(monitor.getItem(), function(item) {
            return item.set('offsetLeft', item.get('offsetLeft') + delta.x)
                       .set('offsetTop', item.get('offsetTop') + delta.y);
          });
        }
      };

      function collectTarget(connect, monitor) {
        return {
          connectDropTarget: connect.dropTarget(),
          isOver: monitor.isOver(),
          canDrop: monitor.canDrop()
        };
      }

      class VatView extends React.Component {
        constructor(props) {
          super(props);
          this.state = {inputValue: ''};
        }
        render() {
          var items = this.props.vat.try_copy_all({name: ma.match.ANY});
          return this.props.connectDropTarget(
              <div>
                <input type="text"
                    ref="nameInput"
                    value={this.state.inputValue}
                    onChange={this.handleChange.bind(this)}
                    onKeyUp={this.handleKeyUp.bind(this)}></input>
                <div className="vat">{
                  items.map((x) => <Card ref={'item-' + x.get('id')} value={x} />)
                }</div>
              </div>
          );
        }
        componentDidMount() {
          React.findDOMNode(this.refs.nameInput).focus();
          viewComponent = this;
        }
        componentWillReceiveProps(nextProps) {
          vat.step();
        }
        handleKeyUp(e) {
          if (e.keyCode === 13) {
            var name = this.state.inputValue;
            var value = {name: name};
            if (name.length === 1 && '+-*/'.indexOf(name) >= 0) {
              value.x = null;
              value.y = null;
            }
            vat.put(value);
            this.setState({inputValue: ''});
          }
        }
        handleChange(e) {
          this.setState({inputValue: e.target.value});
        }
      }

      var DraggableVatView = DragDropContext(ReactDnD.HTML5)(
          DropTarget('card', viewTarget, collectTarget)(VatView)
      );

      // Main
      // ----

      var vat = new ma.Vat();
      vat.comparator = function(a, b) {
        return a.value.get('id') - b.value.get('id');
      }
      var id = 0;

      // ------
      // Process which gives all new objects an 'id' field.
      function objWithoutId(obj) {
        return Immutable.Map.isMap(obj) && !obj.has('id');
      }
      vat.watch(objWithoutId, function(match) {
        vat.update(match, function(obj) { return obj.set('id', id++); });
      });
      // ------

      // ------
      // Process which gives all new objects an offsetTop and offsetLeft field.
      function objWithoutOffsets(obj) {
        return Immutable.Map.isMap(obj) && !obj.has('offsetTop') && obj.has('id');
      }
      vat.watch(objWithoutOffsets, function(match) {
        var top = Math.abs(rand(100, 0));
        var left = Math.abs(rand(100, 0));
        vat.update(match, function(obj) { return obj.set('offsetTop', top).set('offsetLeft', left); });
      });
      // ------

      function isNumberTile(x) {
        return Immutable.Map.isMap(x) &&
               !Number.isNaN(parseInt(x.get('name'), 10)) &&
               x.has('id') &&
               x.has('offsetTop');
      }

      function dist(a, b) {
        var pos1 = {
          x: a.offsetLeft + a.offsetWidth / 2,
          y: a.offsetTop + a.offsetHeight / 2
        };
        var pos2 = {
          x: b.offsetLeft + b.offsetWidth / 2,
          y: b.offsetTop + b.offsetHeight / 2
        };
        return Math.sqrt(
          Math.pow(pos1.x - pos2.x, 2) +
          Math.pow(pos1.y - pos2.y, 2));
      }

      function nodeForTile(t) {
        return React.findDOMNode(viewComponent.refs['item-' + t.get('id')]);
      }

      // ------
      // An agent which tries to bind number tiles and '+' tiles.
      vat.watch(
        and(all({id: _, name: '+', x: null, y: _, offsetTop: _}),
            all(isNumberTile)),
        function(plusTiles, numberTiles) {
          if (viewComponent) {
            plusTiles.forEach(t => tryLink(t, numberTiles));
          }
        }
      );
      // ------

      function tryLink(plusItem, numberTiles) {
        var plusNode = nodeForTile(plusItem);
        numberTiles.forEach(n => {
          var numberNode = nodeForTile(n);
          var delta = dist(plusNode, numberNode);
          if (delta < 1.3 * plusNode.offsetWidth) {
            console.log('link', n.toJS(), 'with', plusItem.toJS());
          }
        });
      }

/*
      var plusPattern = {id: _, name: '+', x: null, y: _, offsetTop: _};

      vat.addObserver(plusPattern, function(obj, id, y, _) {
        tryLink(obj, vat.try_copy_all(isNumberTile));
      });

      vat.addObserver(isNumberTile, function(tup, _) {
        var numbers = vat.try_copy_all(isNumberTile);
        vat.try_copy_all(plusPattern).forEach(function(x, y) {
          tryLink(x, numbers);
        });
      });

      // Bind the left if unbound.
      vat.addReaction({
        patterns: [{id: _, name: '+', x: null, y: _, offsetTop: _}, ALL(isNumberTile)],
        callback: function(tup, plusItems, numbers, a, b) {
          /*
          numbers = numbers.filter(function(x) {
            return dist(plusItem, x) < 50;
          });

          // Sumpin' weird is going on here....
          /*
          .sort(function(a, b) {
            return dist(plusItem, a) - dist(plusItem, b);
          });

          console.log(numbers.map(function(x) { return x.toJS(); }));

          if (numbers.length === 0) {
            return ma.Vat.ABORT;
          }
          var num = numbers.pop();

          var tileObj = tup[0];
          return tileObj.set('x', num);
          return ma.Vat.ABORT;
        }
      });
      // Bind the right if unbound.
      vat.addReaction({
        patterns: [{id: _, op: '+', left: _, right: null}, ALL(isNumberTile)],
        callback: function(tup, id, l, numbers) {
          return null;
          return [x, '+', y];
        }
      });
*/

      function test() {
        vat.put({name: '+', x: null, y: null});
        vat.put({name: '3'});
//        assert(vat.size() === 2);

        vat.put({name: '+', x: null, y: null});
//        assert(vat.size() === 2);
//        vat.step();
      }
      test();

      var viewComponent;
      vat.on('change', function() {
        React.render(<DraggableVatView vat={vat} />, document.getElementById('container'));
      });
      vat.step();

      // TODO:
      // - Need to be able to observe deletions somehow.
      //   - some kind of "meta" property? E.g. _:removed
      //   - or, a "meta-vat" where events are logged?
      //   - some other way of dealing with these events?
      // - Need to be able to do a take_all in an observer/reaction.
      // - Move reactions/observers out of the main tuple space.
      // - Need to be able to take multiple objects at once!
    </script>
  </body>
</html>
